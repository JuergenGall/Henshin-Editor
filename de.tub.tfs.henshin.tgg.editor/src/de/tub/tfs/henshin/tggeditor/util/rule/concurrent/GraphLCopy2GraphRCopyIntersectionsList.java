package de.tub.tfs.henshin.tggeditor.util.rule.concurrent;

import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.henshin.model.Edge;
import org.eclipse.emf.henshin.model.Graph;
import org.eclipse.emf.henshin.model.Mapping;
import org.eclipse.emf.henshin.model.Node;

import de.tub.tfs.henshin.tgg.TNode;
import de.tub.tfs.henshin.tgg.TripleComponent;
import de.tub.tfs.henshin.tggeditor.util.GraphicalNodeUtil;
import de.tub.tfs.henshin.tggeditor.util.GraphicalRuleUtil;
import de.tub.tfs.henshin.tggeditor.util.rule.copy.Graph2GraphCopyMappingList;


/**
 * 
 * @author Jerry
 *generates and keeps all possible Intersections of two graphs: graphL and graphR 
 */
public class GraphLCopy2GraphRCopyIntersectionsList extends LinkedList<IntersectionHandler>{
	
	/**
	 * 
	 */
	private static final long serialVersionUID = -9018666939055647616L;
	
	private Graph graphL;
	private Graph graphR;
	
	public GraphLCopy2GraphRCopyIntersectionsList(Graph leftGraph, Graph rightGraph){
		super();
		this.graphL = leftGraph;
		this.graphR = rightGraph;
		
		HashMap<Node, List<Node>> singleRuleNodeIntersections = getSingleRuleNodeIntersections();
		while (!singleRuleNodeIntersections.isEmpty()) {
			String output = "Single Rule Node Intersections: ";
			
			for (Node key : singleRuleNodeIntersections.keySet()){
				output+="\n["+Test.outNodeRepresentation(key)+"-->(";
				List<Node> nodes = singleRuleNodeIntersections.get(key);
				
				for (Node n : nodes){
					output+="\n"+Test.outNodeRepresentation(n)+", ";
				}
				output+="); ";
			}
			output+="]";
			//Test.out(output);
			
			
			//while single nodes of ruleL have not been mapped to potential nodes of ruleR
			//get first available pair of nodes
			Node nodeL = (Node) singleRuleNodeIntersections.keySet().toArray()[0];
			List<Node> nodesR = singleRuleNodeIntersections.get(nodeL);
			//for each potential matching node of ruleR
			for (Node nodeR : nodesR){ 
				//first create empty Intersection between copies of graphL and graphR
				IntersectionHandler intersection = new IntersectionHandler(graphL, graphR);
				//get corresponding nodes belonging to the copies of the intersecting graphs generated by the intersection
				Node nodeLcopy = intersection.getGraphL2GraphLCopy().getImage(nodeL);
				Node nodeRcopy = intersection.getGraphR2GraphRCopy().getImage(nodeR);
				//if recursively generated intersection is consistent (valid) and thus added to intersections, 
				//remove all mapped node pairs from the singlenodematches list
				//LinkedList<GraphCopyIntersectionMappings> intersections = new LinkedList<GraphCopyIntersectionMappings>();
				//System.out.println("Intersection?");
				if (generateIntersection(nodeLcopy, nodeRcopy, intersection, true)){
					this.add(intersection);
					/**this.add(intersection);
					for (Mapping m : intersection){
						Node nodeCopyL = m.getOrigin();
						Node nodeCopyR = m.getImage();
						Test.check(nodeCopyL.getGraph()==intersection.getGraphL2GraphCopy().getGraphCopy());
						Test.check(nodeCopyR.getGraph()==intersection.getGraphR2GraphCopy().getGraphCopy());
					}**/
					int c = 0;
					for (List<Node> s : singleRuleNodeIntersections.values()){
						c+= s.size();
					}
					cleanNodeGraphL2NodeGraphRIntersections(singleRuleNodeIntersections, intersection);
					int c2 = 0;
					for (List<Node> s : singleRuleNodeIntersections.values()){
						c2+= s.size();
					}
					Test.check(c!=c2);
				}; 
			}
			//after processing all nodes from ruleR, remove whole list from mapping
			singleRuleNodeIntersections.remove(nodeL);
		}
	}
	
	/**
	private static void mergeDisjointIntersectionAndAdd(HashMap<Node,Node>[] inters1,
			HashMap<Node,Node>[] inters2,
			HashMap<Graph[], HashMap<Node,Node>[]> new_graphCopies2Intersection_Isomos){
		
		HashMap<Node, Node> res_g1a_2_copy = new HashMap<Node, Node>();
		HashMap<Node, Node> res_copy_2_g1a = new HashMap<Node, Node>();
		Graph res_graph1a = GraphUtil.copyGraph(g1, res_g1a_2_copy, res_copy_2_g1a, true);
		
		HashMap<Node, Node> res_g1b_2_copy = new HashMap<Node, Node>();
		HashMap<Node, Node> res_copy_2_g1b = new HashMap<Node, Node>();
		Graph res_graph1b = GraphUtil.copyGraph(g1, res_g1b_2_copy, res_copy_2_g1b, true);
		
		HashMap<Node, Node> res_g2a_2_copy = new HashMap<Node, Node>();
		HashMap<Node, Node> res_copy_2_g2a = new HashMap<Node, Node>();
		Graph res_graph2a = GraphUtil.copyGraph(g2, res_g2a_2_copy, res_copy_2_g2a, true);
		
		HashMap<Node, Node> res_g2b_2_copy = new HashMap<Node, Node>();
		HashMap<Node, Node> res_copy_2_g2b = new HashMap<Node, Node>();
		Graph res_graph2b = GraphUtil.copyGraph(g2, res_g2b_2_copy, res_copy_2_g2b, true);
		
		Graph[] res_graphs = {res_graph1a, res_graph2a, res_graph1b, res_graph2b};
		
		HashMap<Node, Node> res_inters_a= new HashMap<Node, Node>();
		HashMap<Node, Node> res_inters_b= new HashMap<Node, Node>();
		
		for (Node old_node1 : old_inters.keySet()){
			Node old_node2 = old_inters.get(old_node1);
			//Node n2 = old_sub_nodes2l.get(i);
			Node resulting_node1a = null;
			for (Node r_node1a : res_graph1a.getNodes()){
				if (NodeUtil.isCopy(r_node1a, old_node1)){
					resulting_node1a = r_node1a;
					break;
				}
			}
			Node resulting_node2a = null;
			for (Node r_node2a : res_graph2a.getNodes()){
				if (NodeUtil.isCopy(r_node2a, old_node2)){
					resulting_node2a = r_node2a;
					break;
				}
			}
			Node resulting_node1b = null;
			for (Node r_node1b : res_graph1b.getNodes()){
				if (NodeUtil.isCopy(r_node1b, old_node1)){
					resulting_node1b = r_node1b;
					break;
				}
			}
			Node resulting_node2b = null;
			for (Node r_node2b : res_graph2b.getNodes()){
				if (NodeUtil.isCopy(r_node2b, old_node2)){
					resulting_node2b = r_node2b;
					break;
				}
			}
			res_inters_a.put(resulting_node1a, resulting_node2a);
			res_inters_b.put(resulting_node1b, resulting_node2b);
		}
		
		for (Node new_node1 : new_inters.keySet()){
			Node new_node2 = new_inters.get(new_node1);
			//Node n2 = old_sub_nodes2l.get(i);
			Node resulting_node1a = null;
			for (Node r_node1a : res_graph1a.getNodes()){
				if (NodeUtil.isCopy(r_node1a, new_node1)){
					resulting_node1a = r_node1a;
					break;
				}
			}
			Node resulting_node2a = null;
			for (Node r_node2a : res_graph2a.getNodes()){
				if (NodeUtil.isCopy(r_node2a, new_node2)){
					resulting_node2a = r_node2a;
				}
			}
			
			Node resulting_node1b = null;
			for (Node r_node1b : res_graph1b.getNodes()){
				if (NodeUtil.isCopy(r_node1b, new_node1)){
					resulting_node1b = r_node1b;
					break;
				}
			}
			Node resulting_node2b = null;
			for (Node r_node2b : res_graph2b.getNodes()){
				if (NodeUtil.isCopy(r_node2b, new_node2)){
					resulting_node2b = r_node2b;
				}
			}
			res_inters_a.put(resulting_node1a, resulting_node2a);
			res_inters_b.put(resulting_node1b, resulting_node2b);
		}
		
		HashMap<?,?>[] resulting_mappings = {res_inters_a, res_g1a_2_copy, res_copy_2_g1a, res_g2a_2_copy, res_copy_2_g2a,
											 res_inters_b, res_g1b_2_copy, res_copy_2_g1b, res_g2b_2_copy, res_copy_2_g2b};
		res_new_graphs2mappings.put(res_graphs, (HashMap<Node,Node>[]) resulting_mappings);
		
	}

	
	private static void mergeDisjointIntersectionsAndAdd(HashMap<Graph[], HashMap<Node,Node>[]> graphCopies2Intersection_Isomos){
		HashMap<Graph[], HashMap<Node,Node>[]> new_graphCopies2Intersection_Isomos
		= new HashMap<Graph[], HashMap<Node,Node>[]>();
		Object[] graphCs = graphCopies2Intersection_Isomos.keySet().toArray();
		for (int i=0;i<graphCs.length;i++){
			for (int j=i;j<graphCs.length;j++){
				if (i==j) continue;
				Graph[] graphCs1 = (Graph[]) graphCs[i];
				Graph[] graphCs2 = (Graph[]) graphCs[j];
				HashMap<Node,Node> inters1 = graphCopies2Intersection_Isomos.get(graphCs1)[0];
				HashMap<Node,Node> inters2 = graphCopies2Intersection_Isomos.get(graphCs2)[0];
				if (disjoint(inters1, inters2)){
					mergeDisjointIntersectionAndAdd(inters1, inters2, new_graphCopies2Intersection_Isomos);
				}
			}
		}
	}
	
	private static void generateAllIntersections(Graph g1, Graph g2, HashMap<Graph[], HashMap<Node,Node>[]> oldgraphs2mappings, HashMap<Graph[], HashMap<Node, Node>[]> newgraphs2mappings){
		HashMap<Graph[], HashMap<Node, Node>[]> res_new_graphs2mappings = new HashMap<Graph[], HashMap<Node,Node>[]>();
		for (Graph[] graphs : oldgraphs2mappings.keySet()){
			HashMap<Node,Node>[] old_mappings = oldgraphs2mappings.get(graphs);
			HashMap<Node, Node> old_inters = old_mappings[0];
			//LinkedList<Node> old_sub_nodes2l = old_sub_nodes[1];
			for (Graph[] newgraphs : newgraphs2mappings.keySet()){
				HashMap<Node, Node>[] new_mappings = newgraphs2mappings.get(newgraphs);
				if (!intersects(old_mappings, new_mappings)){
					
				}
			}
		}
		oldgraphs2mappings.putAll(newgraphs2mappings);
		if (!res_new_graphs2mappings.isEmpty()) generateAllIntersections(g1, g2, oldgraphs2mappings, res_new_graphs2mappings);
	}
	
	
	private static boolean disjoint(HashMap<Node, Node>[] mappings1, HashMap<Node, Node>[] mappings2){
		if (mappings1.length<1) throw new IllegalArgumentException("mappings has to be nonempty");
		if (mappings2.length<1) throw new IllegalArgumentException("mappings has to be nonempty");
		HashMap<Node,Node> l11 = mappings1[0];
		HashMap<Node, Node> l21 = mappings2[0];
		for (Node n1 : l11.keySet()){
			for(Node n2 : l21.keySet()){
				if (NodeUtil.isCopy(n1, n2)) return false;
			}
		}
		
		for (Node n1 : l11.values()){
			for(Node n2 : l21.values()){
				if (NodeUtil.isCopy(n1, n2)) return false;
			}
		}
		return true;
	}**/
	
	//removing matching node pairs from single node intersections list, that appear in new intersection
	private static void cleanNodeGraphL2NodeGraphRIntersections(HashMap<Node, List<Node>> nodeGraphL2nodeGraphRIntersections,
			IntersectionHandler graphLCopy2GraphRCopyIntersection){
		
		Graph2GraphCopyMappingList graphL2graphLCopy = graphLCopy2GraphRCopyIntersection.getGraphL2GraphLCopy();
		Graph2GraphCopyMappingList graphR2graphRCopy = graphLCopy2GraphRCopyIntersection.getGraphR2GraphRCopy();
		
		//for each pair of matching nodes from newly found intersection on copies 
			for (Mapping nodeGraphLCopy2nodeGraphRCopy : graphLCopy2GraphRCopyIntersection){
				Node intersectingNodeGraphLCopy = nodeGraphLCopy2nodeGraphRCopy.getOrigin();
				Node intersectingNodeGraphRCopy = nodeGraphLCopy2nodeGraphRCopy.getImage();
				//get corresponding node pair from initial graphs single node intersections if present
				Node intersectingNodeGraphL = null;
				List<Node> intersectingNodesGraphR = null;
				//HashSet<Node> copiedNodes = new HashSet<Node>();
				for (Node nodeGraphL : nodeGraphL2nodeGraphRIntersections.keySet()){
					if (graphL2graphLCopy.getImage(nodeGraphL)==intersectingNodeGraphLCopy){
					//if (NodeUtil.isCopy(nodeGraphL, nodeInterGraphCopyL, copiedNodes)){
						intersectingNodeGraphL = nodeGraphL;
						intersectingNodesGraphR = nodeGraphL2nodeGraphRIntersections.get(nodeGraphL);
						break;
					}
				}
				
				if (intersectingNodesGraphR!=null){
					Node intersectingNodeGraphR = null;
					for (Node nodeGraphR : intersectingNodesGraphR){
						if (graphR2graphRCopy.getImage(nodeGraphR)==intersectingNodeGraphRCopy){
						//if (NodeUtil.isCopy(nodeRtest, nodeGraphRCopy, copiedNodes)){
							intersectingNodeGraphR = nodeGraphR;
							break;
						}
					}
					if (intersectingNodesGraphR.remove(intersectingNodeGraphR) && intersectingNodesGraphR.isEmpty()){
						nodeGraphL2nodeGraphRIntersections.remove(intersectingNodeGraphL);
					}
				}
		}
	}
	
	
	
	private void getCorrespondences(boolean incoming, Node node, List<Node> corrNodes, List<Edge> corrEdges){
		if (corrNodes==null || corrEdges==null) return;
		EList<Edge> nodeEdges = (incoming ? node.getIncoming() : node.getOutgoing());
		for (Edge corrEdge : nodeEdges){
			//if (iGraphLCopy2iGraphRCopy.containsEdge(oEdgeiNodeGraphCopyL)) continue;
			Node corrNode = (incoming ? corrEdge.getSource() : corrEdge.getTarget());
			if (GraphicalNodeUtil.isCorrNode(corrNode)){
				corrNodes.add(corrNode);
				corrEdges.add(corrEdge);
			}
		}
	}
	
	
	private boolean isIntersectingCorrespondence(
			Node iNodeGraphCopyL, 
			Node iNodeGraphCopyR,
			IntersectionHandler iGraphL2iGraphR, 
			Map<Node, Node> nodeL2nodeR){
		if (iGraphL2iGraphR.getImage(iNodeGraphCopyL, iNodeGraphCopyR.getGraph())==iNodeGraphCopyR) return true;
		//iGraphL2iGraphR.persistTemporaryChanges();
		boolean inComingEdges = false;
		boolean nodesSwaped = false;
		boolean found = false;
		do{
			EList<Edge> edgesiNodeGraphCopyL = (inComingEdges ? iNodeGraphCopyL.getIncoming() : iNodeGraphCopyL.getOutgoing());
			for (Edge edgeiNodeGraphCopyL : edgesiNodeGraphCopyL){
				Node iNodeGraphCopyLAssociate = (inComingEdges ? edgeiNodeGraphCopyL.getSource() : edgeiNodeGraphCopyL.getTarget());
				found = false;
				EList<Edge> edgesiNodeGraphCopyR = (inComingEdges ? iNodeGraphCopyR.getIncoming() : iNodeGraphCopyR.getOutgoing());
				for (Edge edgeiNodeGraphCopyR : edgesiNodeGraphCopyR){
					Node iNodeGraphCopyRAssociate = (inComingEdges ? edgeiNodeGraphCopyR.getSource() : edgeiNodeGraphCopyR.getTarget());
					Node L = (nodesSwaped ? iNodeGraphCopyRAssociate : iNodeGraphCopyLAssociate);
					Node R = (nodesSwaped ? iNodeGraphCopyLAssociate : iNodeGraphCopyRAssociate);
					if (iGraphL2iGraphR.potentialIntersection(L, R)
							&& !(nodeL2nodeR.get(L)!=null && nodeL2nodeR.get(L)!=R)
							){
						nodeL2nodeR.put(L, R);
						//iGraphL2iGraphR.addEdges(oEdgeL, oEdgeR);
						/**
						if (!iGraphL2iGraphR.addIntersection(L, R)){
							if (!iGraphL2iGraphR.isConsistent()){
								iGraphL2iGraphR.undoTemporaryChanges();
								return false;
							}
						}else**/{
							found = true;
							break;
						}
					}	
				}
				if (!found){
					//iGraphL2iGraphR.undoTemporaryChanges();
					return false;
				}
			}
			if (inComingEdges && nodesSwaped) break;
			//false -> true -> false -> true
			inComingEdges=!inComingEdges;
			//true -> false -> true
			if (!inComingEdges){//false -> true-> false
				Node tmp = iNodeGraphCopyL;
				iNodeGraphCopyL = iNodeGraphCopyR;
				iNodeGraphCopyR = tmp;
				//false -> true -> true
				nodesSwaped = true;
			}
		} while(true);
		//if (!iGraphL2iGraphR.addIntersection(iNodeGraphCopyL, iNodeGraphCopyR)) 
			//throw new IllegalArgumentException("Correspondence nodes should always be treated as intersecting nodes");
		//iGraphL2iGraphR.persistTemporaryChanges();
		return true;
	}
	
	private boolean generateIntersection(
			Node iNodeGraphL,
			Node iNodeGraphR,
			IntersectionHandler iGraphL2iGraphR, 
			boolean allowPartialIntersection) throws IllegalArgumentException{
		/*
		if (iGraphL2iGraphR.containsOrigin(iNodeGraphL) && iGraphL2iGraphR.containsImage(iNodeGraphR)){
			return (iGraphL2iGraphR.getImage(iNodeGraphL, iNodeGraphR.getGraph())==iGraphL2iGraphR.getOrigin(iNodeGraphR));
		}else if (iGraphL2iGraphR.containsOrigin(iNodeGraphL) || iGraphL2iGraphR.containsImage(iNodeGraphR)){
			return false;
		}*/
		if (iGraphL2iGraphR.getImage(iNodeGraphL, iNodeGraphR.getGraph())==iNodeGraphR) return true;
		
		if (GraphicalNodeUtil.isCorrNode(iNodeGraphL)){
			HashMap<Node,Node> nodeL2nodeR = new HashMap<Node, Node>();
			if (!GraphicalNodeUtil.isCorrNode(iNodeGraphR)) throw new IllegalArgumentException("types of starting nodes should be equal");
			iGraphL2iGraphR.persistTemporaryChanges();
			if (!isIntersectingCorrespondence(iNodeGraphL, iNodeGraphR, iGraphL2iGraphR, nodeL2nodeR)) return false;
			for (Node nodeL : nodeL2nodeR.keySet()){
				Node nodeR = nodeL2nodeR.get(nodeL);
					if (!generateIntersection(nodeL, nodeR, iGraphL2iGraphR, allowPartialIntersection)){
						iGraphL2iGraphR.undoTemporaryChanges();
						return false;
					}
			}
			if (!iGraphL2iGraphR.addIntersection(iNodeGraphL, iNodeGraphR))throw new IllegalArgumentException("Problem");
			iGraphL2iGraphR.persistTemporaryChanges();
			return true;
		}
		
		//IntersectingAttributesHandler iAttHandler = iGraphL2iGraphR.getIntersectingAttributesHandler();
		if (!iGraphL2iGraphR.addIntersection(iNodeGraphL, iNodeGraphR)) return false;
		
		List<Node> corrNodesFromiNodeGraphL = new LinkedList<Node>();
		List<Edge> corrEdgesFromiNodeGraphL = new LinkedList<Edge>();
		List<Node> corrNodesToiNodeGraphL = new LinkedList<Node>();
		List<Edge> corrEdgesToiNodeGraphL = new LinkedList<Edge>();
		List<Node> corrNodesFromiNodeGraphR = new LinkedList<Node>();
		List<Edge> corrEdgesFromiNodeGraphR = new LinkedList<Edge>();
		List<Node> corrNodesToiNodeGraphR = new LinkedList<Node>();
		List<Edge> corrEdgesToiNodeGraphR = new LinkedList<Edge>();
		
		getCorrespondences(false, iNodeGraphL, corrNodesFromiNodeGraphL, corrEdgesFromiNodeGraphL);
		getCorrespondences(true, iNodeGraphL, corrNodesToiNodeGraphL, corrEdgesToiNodeGraphL);
		getCorrespondences(false, iNodeGraphR, corrNodesFromiNodeGraphR, corrEdgesFromiNodeGraphR);
		getCorrespondences(true, iNodeGraphR, corrNodesToiNodeGraphR, corrEdgesToiNodeGraphR);
		
		boolean found = false;
		if (!(corrNodesFromiNodeGraphL.isEmpty()||corrNodesFromiNodeGraphR.isEmpty())){
			for (Node corrL : corrNodesFromiNodeGraphL){
				found = false;
				for (Node corrR : corrNodesFromiNodeGraphR){
					if (generateIntersection(corrL, corrR, iGraphL2iGraphR, allowPartialIntersection)){
						found = true;
						break;
					}
				}
				if (!found) return false;
			}
			
			for (Node corrR : corrNodesFromiNodeGraphR){
				found = false;
				for (Node corrL : corrNodesFromiNodeGraphL){
					if (generateIntersection(corrL, corrR, iGraphL2iGraphR, allowPartialIntersection)){
						found = true;
						break;
					}
				}
				if (!found) return false;
			}
		}
		
		if (!(corrNodesToiNodeGraphL.isEmpty()||corrNodesToiNodeGraphR.isEmpty())){
			for (Node corrL : corrNodesToiNodeGraphL){
				found = false;
				for (Node corrR : corrNodesToiNodeGraphR){
					if (generateIntersection(corrL, corrR, iGraphL2iGraphR, allowPartialIntersection)){
						found = true;
						break;
					}
				}
				if (!found) return false;
			}
			
			for (Node corrR : corrNodesToiNodeGraphR){
				found = false;
				for (Node corrL : corrNodesToiNodeGraphL){
					if (generateIntersection(corrL, corrR, iGraphL2iGraphR, allowPartialIntersection)){
						found = true;
						break;
					}
				}
				if (!found) return false;
			}
		}
		
		
		for (Edge edgeLOut : iNodeGraphL.getOutgoing()){
			if (iGraphL2iGraphR.containsOrigin(edgeLOut.getTarget())) continue;
			for (Edge edgeROut : iNodeGraphR.getOutgoing()){
				if (iGraphL2iGraphR.containsImage(edgeROut.getTarget())) continue;
				Node nodeLTarget = edgeLOut.getTarget();
				Node nodeRTarget = edgeROut.getTarget();
				//if (NodeUtil.concurrentMatches(nodeLTarget, nodeRTarget, RuleUtil.getRHSNode(nodeRTarget), iGraphLCopy2iGraphRCopy.getIntersectingAttributesHandler())){
				if (iGraphL2iGraphR.potentialIntersection(nodeLTarget, nodeRTarget)){
					if (!generateIntersection(nodeLTarget, nodeRTarget, iGraphL2iGraphR, allowPartialIntersection)){
						return false;
					}
				}
			}
		}
		
		for (Edge edgeLIn : iNodeGraphL.getIncoming()){
			if (iGraphL2iGraphR.containsOrigin(edgeLIn.getSource())) continue;
			for (Edge edgeRIn : iNodeGraphR.getIncoming()){
				if (iGraphL2iGraphR.containsImage(edgeRIn.getSource())) continue;
				Node nodeLSource = edgeLIn.getSource();
				Node nodeRSource = edgeRIn.getSource();
				//if (NodeUtil.concurrentMatches(nodeLSource, nodeRSource, RuleUtil.getRHSNode(nodeRSource), iGraphLCopy2iGraphRCopy.getIntersectingAttributesHandler())){
				if (iGraphL2iGraphR.potentialIntersection(nodeLSource, nodeRSource)){
					if (!generateIntersection(nodeLSource, nodeRSource, iGraphL2iGraphR, allowPartialIntersection))
						return false;
				}
			}
		}
		
		return true;
	}
	
	/***
	private static Node[] addCorrespondingNodes(Edge edgeLCorr, Node nodeLCorr, Edge edgeRCorr, Node nodeRCorr, IntersectionHandler intersection){
		if (!NodeUtil.isCorrNode(nodeLCorr)){
			throw new IllegalArgumentException("correspondencenode should be of type correspondence");
		}
		if (!NodeUtil.isCorrNode(nodeRCorr)){
			throw new IllegalArgumentException("correspondencenode should be of type correspondence");
		}
		if (nodeLCorr.getOutgoing().size()>2 || nodeLCorr.getIncoming().size()>2){
			//throw new IllegalArgumentException("correspondencenode should have exactly one in and one out going edge");
			return null;
		}
		if (nodeRCorr.getOutgoing().size()>2 || nodeRCorr.getIncoming().size()>2){
			//throw new IllegalArgumentException("correspondencenode should have exactly one in and one out going edge");
			return null;
		}
		IntersectionHandler iAttHandler = intersection.getIntersectingAttributesHandler();
		Node nodeL = null;
		Node nodeR = null;
		boolean outgoing = false;
		Edge oie1 = null;
		for (Edge e1 : nodeLCorr.getOutgoing()){
			if (e1 == edgeLCorr){
				outgoing = true;
			}else{
				oie1 = e1;
			}
		}
		if (outgoing){
			Edge oe2 = null;
			for (Edge e2 : nodeRCorr.getOutgoing()){
				if (e2 == edgeRCorr){
					outgoing = false;
				}else{
					oe2 = e2;
				}
			}
			if (outgoing) throw new IllegalArgumentException("Wrong arguments");
			nodeL = oie1.getTarget();
			nodeR = oe2.getTarget();
			//if (!NodeUtil.concurrentMatches(nodeL, nodeR, RuleUtil.getRHSNode(nodeR), intersection.getIntersectingAttributesHandler())){
			if (!iAttHandler.intersectingGraphNodes(nodeL, nodeR)){
				return null;
			}else{
				intersection.addEdges(oie1, oe2);
			}
		}else{
			for (Edge e1 : nodeLCorr.getIncoming()){
				if (e1 == edgeLCorr){
					outgoing = true;
				}else{
					oie1 = e1;
				}
			}
			if (!outgoing) throw new IllegalArgumentException("Wrong arguments");
			Edge ie2 = null;
			for (Edge e2 : nodeRCorr.getIncoming()){
				if (e2 == edgeRCorr){
					outgoing = false;
				}else{
					ie2 = e2;
				}
			}
			if (outgoing) throw new IllegalArgumentException("Wrong arguments");
			nodeL = oie1.getSource();
			nodeR = ie2.getSource();
			//if (!NodeUtil.concurrentMatches(nodeL, nodeR, RuleUtil.getRHSNode(nodeR), intersection.getIntersectingAttributesHandler())){
			if (!iAttHandler.intersectingGraphNodes(nodeL, nodeR)){
				return null;
			}else{
				intersection.addEdges(oie1, ie2);
			}
		}
		intersection.addEdges(edgeLCorr, edgeRCorr);
		intersection.add(nodeLCorr, nodeRCorr);
		intersection.add(nodeL, nodeR);
		Node[] result = {nodeL, nodeR};
		return result;
	}
	
	/**
	 * get mapping of single nodes from ruleL to a List of single nodes of ruleR
	 * @return mapping from ruleL node to all ruleR nodes that are equivalent, e.g. potential matches
	 */
	private HashMap<Node, List<Node>> getSingleRuleNodeIntersections(){
		HashMap<Node, List<Node>> nodeL_nodesR = new HashMap<Node, List<Node>>();
		for (Node nodeL : graphL.getNodes()){
			if (GraphicalNodeUtil.guessTC(nodeL).equals(TripleComponent.CORRESPONDENCE)) continue;
			for (Node nodeR : graphR.getNodes()){//for each pair of nodes
				if (GraphicalNodeUtil.guessTC(nodeR).equals(TripleComponent.CORRESPONDENCE)) continue;
				//if (NodeUtil.concurrentMatches(nodeL, nodeR, RuleUtil.getRHSNode(nodeR), null)){// if nodeL and nodeR are of same type and node1 contains all attributed of nodeR
				if (ConcurrentRuleUtil.sameNodeType(nodeL, nodeR)){	
					if (nodeL_nodesR.get(nodeL)!=null){//if nodeL already had a match in RightGraph simply add nodeR to the existing list of matches
						nodeL_nodesR.get(nodeL).add(nodeR);
					}else{
						LinkedList<Node> list = new LinkedList<Node>();//else create new list with nodeR and add list in map
						list.add(nodeR);
						nodeL_nodesR.put(nodeL, list);
					}
				}
			}
		}
		return nodeL_nodesR;
	}

}
